{
  
    
        "post0": {
            "title": "Other",
            "content": "So your on Windows using python &gt;= 3.8, you have built OpenCV &gt;= 4.6 from source, manually copied .. python path them to your distributions site... directory, added the path to the directory containing opencv.dll and any other shared library dependencies and your seeing something similar to the following. . #os.environ[&quot;OpenCV_LOADER_DEBUG&quot;]=&quot;1&quot; import cv2 . ModuleNotFoundError Traceback (most recent call last) Input In [1], in &lt;cell line: 3&gt;() 1 #import os 2 #os.environ[&#34;OpenCV_LOADER_DEBUG&#34;]=&#34;1&#34; -&gt; 3 import cv2 ModuleNotFoundError: No module named &#39;cv2&#39; . What&#39;s going on? Although the message is quite explicit regarding the cause, it doesn&#39;t really help with finding a solution. In a nutshell python has found .pyd (shared lib), tried and failed to load it because a it can&#39;t find a dependant shared library. Now the advice I have seen online regarding this is to dig out trusty dependancy walker, load the .pyd and see which dependencies the system can&#39;t find. . Now this is solid advice if we had a C++ application and/or we were using python &lt; 3.8 (which uses the system/user path for dll re), however we are not, so even if dependency walker can&#39;t detect any problems we may still be facing the above error. . There is a missing dll, which needs to be added with ... before calling import cv2, now if you have installed the python loader with OpenCV then you will likeliy need to search with .... to find it, however if you have not you may be able to try the quick fix below may work for you . Quick fix when not using the OpenCV python loader . Using the flag OPENCV_SKIP_PYTHON_LOADER=ON prevents the python bindings from being installed when you build install OpenCV, therefore depending on how you installed cv2 there shouldn&#39;t be a cv2 directory inside lib/site-sitepackages and you should something similar to the following . There are multiple reasons that the OpenCV python loader may be missing 1) You didn&#39;t build install . 2) OPENCV_SKIP_PYTHON_LOADER=ON was passed to cmake . 3) The lib/site-packages/cv2 diretory was deleted . Whatever the reason if you are seeing the above error you have likely manually &quot;installed&quot; the python bindings either with . 1) set PYTHONPATH=&quot;OPENCV_BUILD_PATH/lib/python3/&quot; . 2) or by manually copying .... pyd to the lib/site-packages/ . Whichever way this was performed, you will be missing (unless your using a distribution which automatically adds .. directories from the path to the dll search path) . os.add_dll_directory(&quot;OPENCV_BUID_PATH/bin/&quot;); . in this case there will be at least one dll search path which needs to be added. . import os; OPENCV_BUID_PATH = &quot;D:/build/opencv/cuda_11_7_cc_8_6_ff_sym/&quot; os.add_dll_directory(OPENCV_BUID_PATH + &quot;/bin/&quot;); import cv2 . ImportError Traceback (most recent call last) Input In [24], in &lt;cell line: 5&gt;() 3 OPENCV_BUID_PATH = &#34;D:/build/opencv/cuda_11_7_cc_8_6_ff_sym/&#34; 4 os.add_dll_directory(OPENCV_BUID_PATH + &#34;/bin/&#34;); -&gt; 5 import cv2 ImportError: DLL load failed while importing cv2: The specified module could not be found. . . If that didn&#39;t work and you are using the CUDA modules you will also need to add os.add_dll_directory(&quot;C: Program Files NVIDIA GPU Computing Toolkit CUDA v11.7 bin&quot;);, if that doesn&#39;t work then you need to locate the missing dll and manually add it, seee ... . os.add_dll_directory(&quot;C: Program Files NVIDIA GPU Computing Toolkit CUDA v11.7 bin&quot;); import cv2 . ImportError Traceback (most recent call last) Input In [25], in &lt;cell line: 3&gt;() 1 #collapse-output 2 os.add_dll_directory(&#34;C: Program Files NVIDIA GPU Computing Toolkit CUDA v11.7 bin&#34;); -&gt; 3 import cv2 ImportError: DLL load failed while importing cv2: The specified module could not be found. . . import sysconfig import os os.listdir(sysconfig.get_paths()[&quot;purelib&quot;]+&quot;/cv2&quot;) . FileNotFoundError Traceback (most recent call last) Input In [13], in &lt;cell line: 3&gt;() 1 import sysconfig 2 import os -&gt; 3 os.listdir(sysconfig.get_paths()[&#34;purelib&#34;]+&#34;/cv2&#34;) FileNotFoundError: [WinError 3] The system cannot find the path specified: &#39;C: Users b mambaforge Lib site-packages/cv2&#39; . In this case you will definitely be missing the directory containing .... and ... and if you built with CUDA you will also be missing ... therefore before doing anything else . You have installed the python loader .",
            "url": "https://cudawarped.github.io/opencv_docs/opencv/cuda/python/2022/07/26/test.html",
            "relUrl": "/opencv/cuda/python/2022/07/26/test.html",
            "date": " • Jul 26, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "ImportError: DLL load failed while importing cv2: The specified module could not be found.",
            "content": ". So your on Windows using python &gt;= 3.8, you have built OpenCV &gt;= 4.6 from source, manually copied .. python path them to your distributions site... directory, added the path to the directory containing opencv.dll and any other shared library dependencies and your seeing something similar to the following. . #os.environ[&quot;OpenCV_LOADER_DEBUG&quot;]=&quot;1&quot; import cv2 . ModuleNotFoundError Traceback (most recent call last) Input In [1], in &lt;cell line: 3&gt;() 1 #import os 2 #os.environ[&#34;OpenCV_LOADER_DEBUG&#34;]=&#34;1&#34; -&gt; 3 import cv2 ModuleNotFoundError: No module named &#39;cv2&#39; . What&#39;s going on? Although the message is quite explicit regarding the cause, it doesn&#39;t really help with finding a solution. In a nutshell python has found .pyd (shared lib), tried and failed to load it because a it can&#39;t find a dependant shared library. Now the advice I have seen online regarding this is to dig out trusty dependancy walker, load the .pyd and see which dependencies the system can&#39;t find. . Now this is solid advice if we had a C++ application and/or we were using python &lt; 3.8 (which uses the system/user path for dll re), however we are not, so even if dependency walker can&#39;t detect any problems we may still be facing the above error. . There is a missing dll, which needs to be added with ... before calling import cv2, now if you have installed the python loader with OpenCV then you will likeliy need to search with .... to find it, however if you have not you may be able to try the quick fix below may work for you . Quick fix when not using the OpenCV python loader . Using the flag OPENCV_SKIP_PYTHON_LOADER=ON prevents the python bindings from being installed when you build install OpenCV, therefore depending on how you installed cv2 there shouldn&#39;t be a cv2 directory inside lib/site-sitepackages and you should something similar to the following . There are multiple reasons that the OpenCV python loader may be missing 1) You didn&#39;t build install . 2) OPENCV_SKIP_PYTHON_LOADER=ON was passed to cmake . 3) The lib/site-packages/cv2 diretory was deleted . Whatever the reason if you are seeing the above error you have likely manually &quot;installed&quot; the python bindings either with . 1) set PYTHONPATH=&quot;OPENCV_BUILD_PATH/lib/python3/&quot; . 2) or by manually copying .... pyd to the lib/site-packages/ . Whichever way this was performed, you will be missing (unless your using a distribution which automatically adds .. directories from the path to the dll search path) . os.add_dll_directory(&quot;OPENCV_BUID_PATH/bin/&quot;); . in this case there will be at least one dll search path which needs to be added. . import os; OPENCV_BUID_PATH = &quot;D:/build/opencv/cuda_11_7_cc_8_6_ff_sym/&quot; os.add_dll_directory(OPENCV_BUID_PATH + &quot;/bin/&quot;); import cv2 . ImportError Traceback (most recent call last) Input In [24], in &lt;cell line: 5&gt;() 3 OPENCV_BUID_PATH = &#34;D:/build/opencv/cuda_11_7_cc_8_6_ff_sym/&#34; 4 os.add_dll_directory(OPENCV_BUID_PATH + &#34;/bin/&#34;); -&gt; 5 import cv2 ImportError: DLL load failed while importing cv2: The specified module could not be found. . . If that didn&#39;t work and you are using the CUDA modules you will also need to add os.add_dll_directory(&quot;C: Program Files NVIDIA GPU Computing Toolkit CUDA v11.7 bin&quot;);, if that doesn&#39;t work then you need to locate the missing dll and manually add it, seee ... . os.add_dll_directory(&quot;C: Program Files NVIDIA GPU Computing Toolkit CUDA v11.7 bin&quot;); import cv2 . ImportError Traceback (most recent call last) Input In [25], in &lt;cell line: 3&gt;() 1 #collapse-output 2 os.add_dll_directory(&#34;C: Program Files NVIDIA GPU Computing Toolkit CUDA v11.7 bin&#34;); -&gt; 3 import cv2 ImportError: DLL load failed while importing cv2: The specified module could not be found. . . import sysconfig import os os.listdir(sysconfig.get_paths()[&quot;purelib&quot;]+&quot;/cv2&quot;) . FileNotFoundError Traceback (most recent call last) Input In [13], in &lt;cell line: 3&gt;() 1 import sysconfig 2 import os -&gt; 3 os.listdir(sysconfig.get_paths()[&#34;purelib&#34;]+&#34;/cv2&#34;) FileNotFoundError: [WinError 3] The system cannot find the path specified: &#39;C: Users b mambaforge Lib site-packages/cv2&#39; . In this case you will definitely be missing the directory containing .... and ... and if you built with CUDA you will also be missing ... therefore before doing anything else . You have installed the python loader . When you built OpenCV with cmake you didn&#39;t pass OPENCV_SKIP_PYTHON_LOADER=ON and there is a cv2 directory inside site-packages/lib . import sysconfig; import os; os.listdir(sysconfig.get_paths()[&quot;purelib&quot;]+&quot;/cv2&quot;) . FileNotFoundError Traceback (most recent call last) Input In [7], in &lt;cell line: 3&gt;() 1 import sysconfig; 2 import os; -&gt; 3 os.listdir(sysconfig.get_paths()[&#34;purelib&#34;]+&#34;/cv2&#34;) FileNotFoundError: [WinError 3] The system cannot find the path specified: &#39;C: Users b mambaforge Lib site-packages/cv2&#39; . The python loader script should have added the directory to ... and the CUDA SDK if you built with CUDA modules, so to track down the missing . Built OpenCV with OPENCV_SKIP_PYTHON_LOADER=ON . Using the flag OPENCV_SKIP_PYTHON_LOADER=ON prevents the python bindings from being installed when you build install OpenCV, therefore there shouldn&#39;t be a cv2 directory insidde lib/site-sitepackages and you should see the following . import sysconfig; import os; os.listdir(sysconfig.get_paths()[&quot;purelib&quot;]+&quot;/cv2&quot;) . FileNotFoundError Traceback (most recent call last) Input In [9], in &lt;cell line: 3&gt;() 1 import sysconfig; 2 import os; -&gt; 3 os.listdir(sysconfig.get_paths()[&#34;purelib&#34;]+&#34;/cv2&#34;) FileNotFoundError: [WinError 3] The system cannot find the path specified: &#39;C: Users b mambaforge Lib site-packages/cv2&#39; . then you enter something similar to the below in the command prompt before . set PYTHONPATH=&quot;OPENCV_BUILD_PATH/lib/python3/&quot; . set PATH=&quot;OPENCV_BUID_PATH/bin&quot;;%PATH% . or for my set up in python after PYTHONPATH has been parsed . import os OPENCV_BUID_PATH = &quot;D:/build/opencv/cuda_11_7_cc_8_6_ff_sym/&quot; . import sys sys.path.append(OPENCV_BUID_PATH + &quot;/lib/python3/&quot;) sys.path.append(OPENCV_BUID_PATH + &quot;/bin/&quot;) . Advice is to skip loader it is for stand alone distributions https://github.com/opencv/opencv/issues/13202#issuecomment-439730899 Add python path Therefore the discussion assumes that the above is the method used for adding python etc. . import cv2 . ImportError Traceback (most recent call last) Input In [19], in &lt;cell line: 1&gt;() -&gt; 1 import cv2 ImportError: DLL load failed while importing cv2: The specified module could not be found. . What&#39;s going on? Although the message is quite explicit regarding the cause, it doesn&#39;t really help with finding a solution. In a nutshell python has found .pyd (shared lib), tried and failed to load it because a it can&#39;t find a dependant shared library. Now the advice I have seen online regarding this is to dig out trusty dependancy walker, load the .pyd and see which dependencies the system can&#39;t find. . Now this is solid advice if we had a C++ application and/or we were using python &lt; 3.8 (which uses the system/user path for dll re), however we are not, so even if dependency walker can&#39;t detect any problems we may still be facing the above error. . So what to do, well quick a quick and dirty solution is, if you are pretty sure of the folders containing your missing dll&#39;s, just add them to the dll search path in python and see if this reolves your issue. For example if you have built with CUDA then unless you are using something like annaconda, you will need to add the directory containing opencv and hash (bin) and the directory containing the Nvidia shared libs. . you are most likely facing this error becuase the dll&#39;s inside C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/vMAJOR.MINOR/bin cannot be found, so you could try . import os; os.add_dll_directory(OPENCV_BUID_PATH + &quot;/bin/&quot;); os.add_dll_directory(&quot;C: Program Files NVIDIA GPU Computing Toolkit CUDA v11.7 bin&quot;); os.add_dll_directory(&quot;D: 3rd_party deps ffmpeg-n5.0-latest-win64-gpl-shared-5.0 bin&quot;) import cv2 . In my case this solved the problem but what do you do if you don&#39;t know exactly what dll&#39;s are missing, well thanks to alec suggestion you can use process monitor https://docs.microsoft.com/en-us/sysinternals/downloads/procmon on windows to track down the problem. With process monitor you can track the files are opened on the call to import cv2 and see exactly which dll can&#39;t be found. . Using Process Monitor fo find the missing dll . First download/extract/run process monitor. On opening you will be presented with the option to filter the output. We only want to see files which are accesses by the python.exe process, therefore the filter options are . On the dropdown select &quot;Process Name&quot; and in the text box type python.exe and click Add - Process explorer will by defualt output for all processes this will reduce this down to just python. . Then &quot;Operation&quot; is CreateFile -&gt; this . Process monitor produces a lot of output, these settings should filter for . To make things easy to read make sure no other python process are running. . . Now start python and before typing import cv2, press the clear button (red trash can) in process monitor to clear any output generated during pythons initialization. . . The output shows that we successfully found cv2.cp..... which is why were not seeing ModuleNotFoundError: No module named &#39;cv2&#39; however it also shows several attempts have been made to locate opencv_img_hash_460.dll and opencv_world460.dll without success even though they are on the search path. Since Python 3.8.... Therefore we add . import os; os.add_dll_directory(OPENCV_BUID_PATH + &quot;/bin/&quot;); . import cv2 . ImportError Traceback (most recent call last) Input In [7], in &lt;cell line: 1&gt;() -&gt; 1 import cv2 ImportError: DLL load failed while importing cv2: The specified module could not be found. . . Now can see that opencv_img_hash_460.dll and opencv_world460.dll after a few attempts were located successfully however we are missing nppc64_11.dll etc. which are all part of the CUDA toolkit. The solution add these as well and . import os; os.add_dll_directory(&quot;C: Program Files NVIDIA GPU Computing Toolkit CUDA v11.7 bin&quot;); os.add_dll_directory(&quot;D: 3rd_party deps ffmpeg-n5.0-latest-win64-gpl-shared-5.0 bin&quot;) import cv2 . and in my case no more errors. At this point if I was still seeing ImportError: DLL load failed while importing cv2: The specified module could not be found I would continue examining the output of process monitor until I get Result SUCCESS for all the .dll files python.exe tries to locate. . Permanantely fixing . Updating OpenCV&#39;s installed python loader . When OpenCV was installed .... only downside is that if you build install OpenCV again your changes will be lost . Creating python loader . If you have installed the python bindings already this will feel a little bit like re-inventing the wheel, but it has the advantage that you can quickly modify a single file to point to access python bindings for a different OpenCV build without too much trouble and your configuration shouldn&#39;t get overidden . Recursion detected, when python .pyd is missing, check new install includes it, if not copy to lib/python to cv2/python-3.9 directory How to init .",
            "url": "https://cudawarped.github.io/opencv_docs/opencv/cuda/python/2022/07/26/opencv_cvs_dll_load_failed.html",
            "relUrl": "/opencv/cuda/python/2022/07/26/opencv_cvs_dll_load_failed.html",
            "date": " • Jul 26, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "Build and install OpenCV with CUDA and python bindings on Windows",
            "content": "Replace 4.6.0 -&gt; 4-6-0 -&gt; 11.7 2022 3.9 . Introduction . Because the pre-built Windows libraries available for OpenCV 4.6.0 do not include the CUDA modules, or support for the Nvidia Video Codec SDK, Nvidia cuDNN, [Intel Media SDK] (https://software.intel.com/en-us/media-sdk), I have included the build instructions, below for anyone who is interested. If you just need the Windows libraries then go to Download OpenCV 4.6.0 with CUDA 11.7. To get an indication of the performance boost from calling the OpenCV CUDA functions with these libraries see the OpenCV 3.4 GPU CUDA Performance Comparisson (nvidia vs intel). . The guide below details instructions on compiling the 64 bit version of OpenCV 4.6.0 shared libraries with Visual Studio 2022, CUDA 11.7, and optionally the Nvidia Video Codec SDK, Nvidia cuDNN, Intel Media SDK, and Python bindings for accessing OpenCV CUDA modules from within Python. . The main topics covered are given below. Although most of the sections can be read in isolation I recommend reading the pre-build checklist first to check whether you will benefit from and/or need to compile OpenCV with CUDA support. . . Pre-build Checklist . Before continuing there are a few things to be aware of: . This guide is for OpenCV 4.6.0. Whilst the instructions should also work on newer versions, this is not guaranteed so please only ask questions related to the stable 4.6.0 release on this page. | You can download all the pre-built binaries described in this guide from the downloads page. Unless you want to; build for another version of Visual Studio; and/or | include non-free algorithms; and/or | generate CUDA binaries compatible with devices of specific compute capability see Choosing the compute-capability; and/or | use different versions of Nvidia Video Codec SDK or cuDNN; and/or | build bindings for python versions other than to 3.9; | . or just want to build OpenCV from scratch, you may find they are all you need. | If you have already tried to build and are having issues check out the troubleshooting guide. | Thanks to Hamdi Sahloul, since August 2018 the CUDA modules can now be called directly from Python, to include this support see the including Python bindings section. | The procedure outlined has been tested on Visual Studio Community 2019 (16.7.5). | The OpenCV DNN modules are now CUDA accelerated. To target you need to install cuDNN (see the below for instructions) before building. Note: If you want to use your application on a different machine you will need to ensure that the cudnn64_8.dll is installed on that machine, either in a location on the system/user path or in the same directory as your application. | Installing cuDNN will automatically cause OpenCV to be built with the CUDA DNN backend, therefore if you have cuDNN installed but do not wish to build OpenCV with the CUDA backend (making it dependant on cuDNN) you will need to disable the module with -DOPENCV_DNN_CUDA=OFF. | . | If you have built OpenCV with CUDA support then to use those libraries and/or redistribute applications built with them on any machines without the CUDA toolkit installed, you will need to ensure those machines have, an Nvidia capable GPU with driver version of 456.38 or later (see this for a full list of CUDA Toolkit versions and their required drivers), and | the CUDA dll&#39;s (cublas64_11.dll, nppc64_11.dll etc.) placed somewhere on the system or user path, or in the same directory as the executable. These can be located in the following directory. C: Program Files NVIDIA GPU Computing Toolkit CUDA v11.1 bin . | . | The latest version of Intel TBB uses a shared library, therefore if you build with Intel TBB you need to add C: Program Files (x86) IntelSWTools compilers_and_libraries windows redist intel64_win tbb vc_mt . to your path variable, and make sure you redistribute tbb.dll with any of your applications. | Depending on the hardware the build time can be over 3 hours. If this is an issue you can speed this up by generating the build files with ninja and/or targeting a specific CUDA compute capability. | #hide . Prerequisites . There are a couple of components you need to download and/or install before you can get started, you first need to: . Install Visual Studio 2019, selecting the &quot;Desktop development with C++&quot; workload shown in the image below. If you already have an installation ensure that the correct workload is installed and that you have updated to the latest version (16.7.5 is used in this guide). | Download the source files for both OpenCV and OpenCV contrib, available on GitHub. Either clone the git repos OpenCV and OpenCV Contrib making sure to checkout the 4.5.0 tag or download these archives OpenCV 4.5.0 and OpenCV Contrib 4.5.0 containing all the source file. Note: I have seen lots of guides including instructions to download and use git to get the source files, however this is a completely unnecessary step. If you are a developer and you don&#39;t already have git installed and configured then, I would assume there is a good reason for this and I would not advise installing just to build OpenCV. | Install CMake - Version 3.18.4 is used in the guide. | Install The CUDA 11.1 Toolkit. Note: If your system path is too long, CUDA will not add the path to its binaries C: Program Files NVIDIA GPU Computing Toolkit CUDA v11.1 bin during installation. If you receive a warning about this at the end of the installation process do not forget to manually add the path to your system path, otherwise opencv_world450.dll will fail to load. | Optional - To decode video on the GPU with Nvidia Video Codec SDK&lt;/p&gt; Register and download the Video Codec SDK. | Extract and copy the contents of the Interface to the include and the Lib to the lib directory inside your CUDA installation. For CUDA 11.1 your CUDA installation directory is C: Program Files NVIDIA GPU Computing Toolkit CUDA v11.1 . | . Video Codec SDK 10 is used in this guide. Note: Before building you may want to ensure that your GPU has decoding support by refering to Nvidia Video Decoder Support Matrix. | Optional - To use the DNN CUDA backend: Register and download cuDNN. | Extract and copy the bin, include and lib directories to your CUDA installation. For CUDA 11.1 your CUDA installation directory is C: Program Files NVIDIA GPU Computing Toolkit CUDA v11.1 . | . cuDNN v8.0.4.30 is used in this guide. | Optional - To accelerate video decoding on Intel CPU&#39;s with Quick Sync register and download and install Intel Media SDK. | Media SDK 2020 R1 is used in this guide. Optional - To accelerate specific OpenCV operations install both the Intel MKL and TBB by registering for community licensing, and downloading for free. MKL version 2019 Update 5 (2019.0.5.068) and TBB version 2019 Update 8 (2019.0.5.068) are used in this guide, later versions of MKL do not currently compile out of the box (see this issue on github) and I also cannot guarantee that earlier versions will work correctly either. | Optional – To call OpenCV CUDA routines from python, install the x64 bit version of Anaconda3, making sure to tick “Register Anaconda as my default Python ..”. This guide has been tested against Anaconda with Python 3.7, installed in the default location for a single user and Python 3.8 installed in its own conda environment. | Generating OpenCV build files with CMake . Before you can build OpenCV you have to generate the build files with CMake. There are two ways to do this, from the command prompt or with the CMake GUI, however by far the quickest and easiest way to proceed is to use the command prompt to generate the base configuration. Then if you want to add any additional configuration options, you can open up the build directory in the CMake GUI as described here. In addition there are several ways to build OpenCV using Visual Studio. For simplicity only two methods are discussed here: Building OpenCV with Visual Studio solution files. | Building OpenCV with the ninja build system to reduce the build time. | Finally instructions are included for building and using the Python bindings to access the OpenCV CUDA modules. Building OpenCV 4.5.0 with CUDA and Intel MKL + TBB, with Visual Studio solution files from the command prompt (cmd) . The following steps will build the opencv_world450.dll using NVIDIA&#39;s recommended settings for future hardware compatibility. This does however have two drawbacks, first the build can take several hours to complete and second, the shared library will be at least 1.09GB depending on the configuration that you choose below. To find out how to reduce both the compilation time and size of opencv_world450.dll read choosing the compute-capability first and then continue as below. If you wish to build the Python bindings and/or use the Ninja build system then see section including python bindings and/or decreasing the build time with Ninja respectively before proceeding. Open up the command prompt (windows key + r, then type cmd and press enter). | Ignore this step if you are not building with Intel MKL + TBB. Enter the below &quot;C: Program Files (x86) IntelSWTools compilers_and_libraries_2019.5.281 windows mkl bin mklvars.bat&quot; intel64 &quot;C: Program Files (x86) IntelSWTools compilers_and_libraries windows tbb bin tbbvars.bat&quot; intel64 . to temporarily set the environmental variables for locating your MKL and TBB installations. | Set the location of the source files and build directory, by entering the text shown below, first setting PATH_TO_OPENCV_SOURCE to the root of the OpenCV files you downloaded or cloned (the directory containing 3rdparty, apps, build, etc.) and PATH_TO_OPENCV_CONTRIB_MODULES to the modules directory inside the contrib repo (the directory containing cudaarithm, cudabgsegm, etc). set &quot;openCvSource=PATH_TO_OPENCV_SOURCE&quot; set &quot;openCVExtraModules=PATH_TO_OPENCV_CONTRIB_MODULES&quot; set &quot;openCvBuild=%openCvSource% build&quot; set &quot;buildType=Release&quot; set &quot;generator=Visual Studio 16 2019&quot; . | Copy the below to the command prompt. This is the base configuration and will build opencv_world440.dll with CUDA including and the corresponding tests and examples. Additionally if the Nvidia Video Codec SDK, cuDNN or the Intel Media SDK are installed the corresponding modules will automatically be included. &quot;C: Program Files CMake bin cmake.exe&quot; -B&quot;%openCvBuild%/&quot; -H&quot;%openCvSource%/&quot; -G&quot;%generator%&quot; -DCMAKE_BUILD_TYPE=%buildType% -DOPENCV_EXTRA_MODULES_PATH=&quot;%openCVExtraModules%/&quot; ^ -DINSTALL_TESTS=ON -DINSTALL_C_EXAMPLES=ON -DBUILD_EXAMPLES=ON ^ -DBUILD_opencv_world=ON ^ -DWITH_CUDA=ON -DCUDA_TOOLKIT_ROOT_DIR=&quot;C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.1&quot; -DCUDA_FAST_MATH=ON -DWITH_CUBLAS=ON -DCUDA_ARCH_PTX=8.6 -DWITH_NVCUVID=ON ^ -DWITH_OPENGL=ON ^ -DWITH_MFX=ON . Then append the following commands as required, and press enter to run CMake: Remove all optional CUDA modules. This is useful if you only want to use the CUDA backend for the DNN module and will significantly reduce compilation time and size of the opencv_world450.dll. -DBUILD_opencv_cudaarithm=OFF -DBUILD_opencv_cudabgsegm=OFF -DBUILD_opencv_cudafeatures2d=OFF -DBUILD_opencv_cudafilters=OFF -DBUILD_opencv_cudaimgproc=OFF -DBUILD_opencv_cudalegacy=OFF -DBUILD_opencv_cudaobjdetect=OFF -DBUILD_opencv_cudaoptflow=OFF -DBUILD_opencv_cudastereo=OFF -DBUILD_opencv_cudawarping=OFF -DBUILD_opencv_cudacodec=OFF . | Include Intel MLK without multithreading support and dependence on tbb.dll -DWITH_MKL=ON . | Make Intel MKL multi-threaded by adding the following to -DWITH_MKL=ON. Note: This will make opencv_world450.dll dependant on tbb.dll. -DMKL_USE_MULTITHREAD=ON -DMKL_WITH_TBB=ON . | Include Intel TBB - recommended for DNN inference on the CPU. Note: As above this will make opencv_world450.dll dependant on tbb.dll. -DWITH_TBB=ON . | Include non free modules. -DOPENCV_ENABLE_NONFREE=ON -DBUILD_opencv_rgbd=OFF . | . | If you want to make any configuration changes before building, then you can do so now through the CMake GUI. | The OpenCV.sln solution file should now be in your PATH_TO_OPENCV_SOURCE/build directory. To build OpenCV you have two options depending on you preference you can: Build directly from the command line by simply entering the following (swaping Release for Debug to build a release version) &quot;C: Program Files CMake bin cmake.exe&quot; --build %openCvBuild% --target INSTALL --config Debug . | Build through Visual Studio GUI by opening up the OpenCV.sln in Visual Studio, selecting your Configuration, clicking on Solution Explorer, expanding CMakeTargets, right clicking on INSTALL and clicking Build. | . Either approach will both build the library and copy the necessary redistributable parts to the install directory, PATH_TO_OPENCV_SOURCE/build/install in this example. All that is required now to run any programs compiled against these libs is to add the directory containing opencv_world450.dll (and tbb.dll if you have built with Intel TBB) to you path environmental variable. | If everything was successful, congratulations, you now have OpenCV built with CUDA. To quickly verify that the CUDA modules are working and check if there is any performance benefit on your specific hardware see below Decreasing the build time with Ninja . The build time for OpenCV can be reduced by more than 2x (from 2 hours to 30 mins on an i7-8700) by utilizing the ninja build system instead of directly generating Visual Studio solution files. The only difference you may notice is that Ninja will only produce one configuration at a time, either a Debug or Release, therefore the buildType must be set before calling CMake. In the section above the configuration was set to Release, to change it to Debug simply replace Release with Debug as shown below set &quot;buildType=Debug&quot; . Using ninja only requires two extra configuration steps: Configuring Visual Studio Development tools by entering the following into the command prompt before entering the CMake command (changing Community to either Professional or Enterprise if necessary) &quot;C: Program Files (x86) Microsoft Visual Studio 2019 Community VC Auxiliary Build vcvars64.bat&quot; . | Changing the generator from &quot;Visual Studio 16 2019&quot; to ninja set &quot;generator=Ninja&quot; . | For example entering the following into the command prompt will generate ninja build files to build OpenCV with CUDA 11.1 and Python bindings &quot;C: Program Files (x86) Microsoft Visual Studio 2019 Community VC Auxiliary Build vcvars64.bat&quot; set &quot;openCvSource=PATH_TO_OPENCV_SOURCE&quot; set &quot;openCVExtraModules=PATH_TO_OPENCV_CONTRIB_MODULES&quot; set &quot;openCvBuild=%openCvSource% build&quot; set &quot;buildType=Release&quot; set &quot;generator=Ninja&quot; set &quot;pathToAnaconda=PATH_TO_ANACONDA3&quot; set &quot;pyVer=37&quot; &quot;C: Program Files CMake bin cmake.exe&quot; -B&quot;%openCvBuild%/&quot; -H&quot;%openCvSource%/&quot; -G&quot;%generator%&quot; -DCMAKE_BUILD_TYPE=%buildType% -DOPENCV_EXTRA_MODULES_PATH=&quot;%openCVExtraModules%/&quot; ^ -DINSTALL_TESTS=ON -DINSTALL_C_EXAMPLES=ON -DBUILD_EXAMPLES=ON ^ -DBUILD_opencv_world=ON ^ -DWITH_CUDA=ON -DCUDA_TOOLKIT_ROOT_DIR=&quot;C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.1&quot; -DCUDA_FAST_MATH=ON -DWITH_CUBLAS=ON -DCUDA_ARCH_PTX=8.6 -DWITH_NVCUVID=ON ^ -DWITH_OPENGL=ON ^ -DWITH_MFX=ON ^ -DBUILD_opencv_python3=ON -DPYTHON3_INCLUDE_DIR=%pathToAnaconda%/include -DPYTHON3_LIBRARY=%pathToAnaconda%/libs/python%pyVer%.lib -DPYTHON3_EXECUTABLE=%pathToAnaconda%/python.exe -DPYTHON3_NUMPY_INCLUDE_DIRS=%pathToAnaconda%/lib/site-packages/numpy/core/include -DPYTHON3_PACKAGES_PATH=%pathToAnaconda%/Lib/site-packages/ -DOPENCV_SKIP_PYTHON_LOADER=ON . The build can then be started in the same way as before dropping the --config option as &quot;C: Program Files CMake bin cmake.exe&quot; --build %openCvBuild% --target install . Adding additional configuration options with the CMake GUI . Once you have generated the base Visual Studio solution file from the command prompt the easiest way to make any aditional configuration changes is through the CMake GUI. To do this: Fire up the CMake GUI. | Making sure that the Grouped checkbox is ticked, click on the browse build button and navigate to your PATH_TO_OPENCV_SOURCE/build directory. If you have selected the correct directory the main CMake window should resemble the below. | Now any additional configuration changes can be made by just expanding any of the grouped items and ticking or unticking the values displayed. Once you are happy just press Configure, if the bottom window displays configuration successful press Generate, and you should see Now you can open up the Visual Studio solution file and proceed as before. | Troubleshooting: Make sure you have the latest version of Visual Studio 2019 (&gt;= 16.7.5) | Not all options are compatible with each other and the configuration step may fail as a result. If so examine the error messages given in the bottom window and look for a solution. | If the build is failing after making changes to the base configuration, I would advise you to remove the build directory and start again making sure that you can at least build the base Visual Studio solution files produces from the command line | . | Including Python bindings . Building and installing python support is incredibly simple, the instructions below are for python 3.7 and 3.8 however they can easily be adapted for other versions of python aswell. If you have downloaded the pre-built binaries from here then you can simply follow steps 5)-7) after first setting %openCvBuild% to the directory which you have extracted the pre-built binaries to. That is set &quot;%openCvBuild%=EXTRACTED_DIR&quot; where EXTRACTED_DIR contains both the install and lib directories. Python 3.7 in the base conda environment Below are instructions on how to build OpenCV with python bindings in the base anaconda environment, which in our case uses python 3.7 as we installed anaconda with that version. Open up the windows command prompt and enter set &quot;pathToAnaconda=PATH_TO_ANACONDA3&quot; . set &quot;pyVer=37&quot; . ensuring the PATH_TO_ANACONDA3 only uses forward slashes (/) as path seperators and points to the Anaconda3 directory, e.g. C:/Users/mbironi/Anaconda3/. | Follow the instructions from above to build your desired configuration, appending the below to the CMake configuration before running CMake. -DBUILD_opencv_python3=ON -DPYTHON3_INCLUDE_DIR=%pathToAnaconda%/include -DPYTHON3_LIBRARY=%pathToAnaconda%/libs/python%pyVer%.lib -DPYTHON3_EXECUTABLE=%pathToAnaconda%/python.exe -DPYTHON3_NUMPY_INCLUDE_DIRS=%pathToAnaconda%/lib/site-packages/numpy/core/include -DPYTHON3_PACKAGES_PATH=%pathToAnaconda%/Lib/site-packages/ -DOPENCV_SKIP_PYTHON_LOADER=ON . | Make sure you build release, python bindings cannot by default be generated for a debug configuration, that is unless you have specificaly built or downloaded a debug version of python. That said you can easily generate a debug build by modifying the contents of pyconfig.h, changing pragma comment(lib,&quot;python37_d.lib&quot;) . to pragma comment(lib,&quot;python37.lib&quot;) . and # define Py_DEBUG . to //# define Py_DEBUG . The default location of pyconfig.h in Anaconda3 is %USERPROFILE% Anaconda3 include pyconfig.h. However the version you are compiling against may differ, to check the location simply open up CMake in the build directory as detailed in Adding additional configuration options with CMake GUI and check the entries under PYTHON3_INCLUDE_DIR shown below. | Verify that the cmake output detailing the modules to be built includes python3 and if not look for errors in the output preceding the below. -- OpenCV modules: -- To be built: aruco bgsegm bioinspired calib3d ccalib core cudaarithm cudabgsegm cudacodec cudafeatures2d cudafilters cudaimgproc cudalegacy cudaobjdetect cudaoptflow cudastereo cudawarping cudev datasets dnn dnn_objdetect dpm face features2d flann fuzzy hfs highgui img_hash imgcodecs imgproc line_descriptor ml objdetect optflow phase_unwrapping photo plot python2 python3 quality reg rgbd saliency shape stereo stitching structured_light superres surface_matching text tracking ts video videoio videostab world xfeatures2d ximgproc xobjdetect xphoto . | In the current version of OpenCV (4.5.0), once generated the bindings (cv2.cp37-win_amd64.pyd) are copied to the site-packages directory, in our case &quot;%USERPROFILE% Anaconda3 Lib site-packages &quot; . To verify this and ensure that there are no historic installations of OpenCV either through pip or conda before continuing type the following dir &quot;%USERPROFILE% Anaconda3 Lib site-packages cv2*&quot; . and inspect the output 17/04/2019 10:11 &lt;DIR&gt; cv2 12/10/2020 14:56 11,968,000 cv2.cp37-win_amd64.pyd . You need to ensure that the date of the bindings copied to your installation of python (12/10/2020 14:56 in the above case) corresponds to the date and time of the build. Additionaly you must make sure that there are no other entries. In the above example the additional ouput showing a cv2 directory implies that there is an existing installation of OpenCV, either through pip or a previous build. This needs to be removed before continuing, with the method of removeal depending on how it was installed. If for some the above returns File Not Found . first the verify that the python bindings have been built by entering dir &quot;%openCvBuild% lib python3 cv2.cp37-win_amd64.pyd&quot; . or dir &quot;%openCvBuild% lib python3 [Debug|Release] cv2.cp37-win_amd64.pyd&quot; . if you built using from within Visual Studio, and then confirming that the following file exists 12/10/2020 14:56 11,968,000 cv2.cp37-win_amd64.pyd . If the file has been found then this can be manually copied accross using the following which again assumes you have python 3.7 installed through Anaconda in the default location for a single user. copy &quot;%openCvBuild% lib python3 cv2.cp37-win_amd64.pyd&quot; &quot;%USERPROFILE% Anaconda3 Lib site-packages cv2.cp37-win_amd64.pyd&quot; . or copy &quot;%openCvBuild% lib python3 [Debug|Release] cv2.cp37-win_amd64.pyd&quot; &quot;%USERPROFILE% Anaconda3 Lib site-packages cv2.cp37-win_amd64.pyd&quot; . if you built using from within Visual Studio. Alternatively if the above also returns File Not Found then you need to ensure both that the build has completed successfully and that the output from step 4) contains python3. | Include the path to the opencv_world440.dll and opencv_img_hash450.dll shared libraries in your user or system path or temporarily by entering set path=%openCvBuild% install x64 vc16 bin;%path% . | Test the freshly compiled python module can be located and loads correctly by entering python -c &quot;import cv2; print(f&#39;OpenCV: {cv2.__version__} for python installed and working&#39;)&quot; . and checking the output for OpenCV: 4.5.0 for python installed and working . If you do not see the above output then see the troubleshooting section below. | Python 3.8 in a seperate conda environment Below are instructions on how to create and then use a seperate anaconda environment to build the OpenCV python bindings for a different version of python. In this case I have chosen to use a newer version of python than in the base conda environment but any version should work. First open up the Anaconda3 command prompt and create a new environment (py38) containing the base anaconda installed packages and python 3.8 instead of python 3.7 conda create -n py38 anaconda python=3.8 . | Then either continue in the Anaconda3 or windows command prompt entering the following to point to your new environment set &quot;pathToAnaconda=PATH_TO_ANACONDA3_PY38&quot; . set &quot;pyVer=38&quot; . ensuring the PATH_TO_ANACONDA3_PY38 only uses forward slashes (/) as path seperators and points to the Anaconda3 directory, e.g. C:/Users/mbironi/Anaconda3/envs/py38/. | Follow the instructions from above to build your desired configuration, appending the below to the CMake configuration before running CMake. -DBUILD_opencv_python3=ON -DPYTHON3_INCLUDE_DIR=%pathToAnaconda%/include -DPYTHON3_LIBRARY=%pathToAnaconda%/libs/python%pyVer%.lib -DPYTHON3_EXECUTABLE=%pathToAnaconda%/python.exe -DPYTHON3_NUMPY_INCLUDE_DIRS=%pathToAnaconda%/lib/site-packages/numpy/core/include -DPYTHON3_PACKAGES_PATH=%pathToAnaconda%/Lib/site-packages/ -DOPENCV_SKIP_PYTHON_LOADER=ON . | Make sure you build release, python bindings cannot by default be generated for a debug configuration, that is unless you have specificaly built or downloaded a debug version of python. That said you can easily generate a debug build by modifying the contents of pyconfig.h, changing pragma comment(lib,&quot;python38_d.lib&quot;) . to pragma comment(lib,&quot;python38.lib&quot;) . and # define Py_DEBUG . to //# define Py_DEBUG . The default location of pyconfig.h in the Anaconda3 for the py38 environment is %USERPROFILE% Anaconda3 envs py38 include pyconfig.h. However the version you are compiling against may differ, to check the location simply open up CMake in the build directory as detailed in Adding additional configuration options with CMake GUI and check the entries under PYTHON3_INCLUDE_DIR. | Verify that the cmake output detailing the modules to be built includes python3 and if not look for errors in the output preceding the below. -- OpenCV modules: -- To be built: aruco bgsegm bioinspired calib3d ccalib core cudaarithm cudabgsegm cudacodec cudafeatures2d cudafilters cudaimgproc cudalegacy cudaobjdetect cudaoptflow cudastereo cudawarping cudev datasets dnn dnn_objdetect dpm face features2d flann fuzzy hfs highgui img_hash imgcodecs imgproc line_descriptor ml objdetect optflow phase_unwrapping photo plot python2 python3 quality reg rgbd saliency shape stereo stitching structured_light superres surface_matching text tracking ts video videoio videostab world xfeatures2d ximgproc xobjdetect xphoto . | In the current version of OpenCV (4.5.0), once generated the bindings (cv2.cp38-win_amd64.pyd) are copied to the site-packages directory, in our case &quot;%USERPROFILE% Anaconda3 envs py38 Lib site-packages &quot; . To verify this and ensure that there are no historic installations of OpenCV either through pip or conda before continuing type the following dir &quot;%USERPROFILE% Anaconda3 envs py38 Lib site-packages cv2*&quot; . and inspect the output 17/04/2019 10:11 &lt;DIR&gt; cv2 12/10/2020 14:56 11,968,000 cv2.cp38-win_amd64.pyd . You need to ensure that the date of the bindings copied to your installation of python (12/10/2020 14:56 in the above case) corresponds to the date and time of the build. Additionaly you must make sure that there are no other entries. In the above example the additional ouput showing a cv2 directory implies that there is an existing installation of OpenCV, either through pip or a previous build. This needs to be removed before continuing, with the method of removeal depending on how it was installed. If for some the above returns File Not Found . first the verify that the python bindings have been built by entering dir &quot;%openCvBuild% lib python3 cv2.cp38-win_amd64.pyd&quot; . or dir &quot;%openCvBuild% lib python3 [Debug|Release] cv2.cp38-win_amd64.pyd&quot; . if you built using from within Visual Studio, and confirming that the following file exists 12/10/2020 14:56 11,968,000 cv2.cp38-win_amd64.pyd . If the file has been found then this can be manually copied accross using the following. copy &quot;%openCvBuild% lib python3 cv2.cp38-win_amd64.pyd&quot; &quot;%USERPROFILE% Anaconda3 envs py38 Lib site-packages cv2.cp38-win_amd64.pyd&quot; . or copy &quot;%openCvBuild% lib python3 [Debug|Release] cv2.cp38-win_amd64.pyd&quot; &quot;%USERPROFILE% Anaconda3 envs py38 Lib site-packages cv2.cp38-win_amd64.pyd&quot; . if you built using from within Visual Studio. Alternatively if the above also returns File Not Found then you need to ensure both that the build has completed successfully and that the output from step 4) contains python3. | Include the path to the opencv_world440.dll and opencv_img_hash440.dll shared libraries in your user or system path or temporarily by entering set path=%openCvBuild% install x64 vc16 bin;%path% . | Test the freshly compiled python module can be located and loads correctly by entering python -c &quot;import cv2; print(f&#39;OpenCV: {cv2.__version__} for python installed and working&#39;)&quot; . and checking the output for OpenCV: 4.5.0 for python installed and working . If you do not see the above output then see the troubleshooting section below. | If there were no errors from the above steps the Python bindings should be installed correctly. To use on a permanent basis don&#39;t forget to permanently add the path to the opencv_world450.dll shared library to your user or system path. To quickly verify that the CUDA modules can be called and check if there is any performance benefit on your system continue below, then to see how to get the most performance from the OpenCV Python CUDA bindings see Accelerating OpenCV with CUDA streams in Python. Troubleshooting, if the output from step (7) is: ModuleNotFoundError: No module named &#39;cv2&#39; . You have not copied the bindings to your python distribution, see step (5). | ImportError: ERROR: recursion is detected during loading of &quot;cv2&quot; binary extensions. Check OpenCV installation. . Ensure that you don&#39;t have OpenCV installed though conda and/or pip, and that you don&#39;t have another copy of the python bindings in your site-packages directory. | ImportError: DLL load failed: The specified procedure could not be found. . One of the required dll&#39;s is not present on your windows path. From the feedback I have received it is most likely you have not added the location of either the OpenCV shared libraries (opencv_world450.dll and opencv_img_hash440.dll), the path to the CUDA binaries, or the path to tbb.dll if built with Intel TBB. This can be quickly checked by entering in the following where opencv_world450.dll . where opencv_img_hash450.dll . where nppc64_11.dll . where cudnn64_8.dll &amp; :: if you have built the DNN module with the CUDA backend . where tbb.dll &amp; :: if you have built with Intel TBB . and checking that you see the path to the dll in each case. If instead you see INFO: Could not find files for the given pattern(s). . add the paths (step (5) above, step (4) from the Prerequisites and step (6) from the Pre-build Checklist) and check again. Once the you can see the paths to the dll&#39;s check step (7) again. | If you get any other errors, make sure to check OpenCV is installed correctly by running through the steps in Verifying OpenCV is CUDA accelerated. | Troubleshooting common configuration/build errors . CUDA : OpenCV requires enabled &#39;cudev&#39; module from &#39;opencv_contrib&#39; . The most common cause of this is that -DOPENCV_EXTRA_MODULES_PATH has been set to the root of the opencv_contrib repo and not the modules directory. Double check that -DOPENCV_EXTRA_MODULES_PATH=OPENCV_CONTRIB/modules . not -DOPENCV_EXTRA_MODULES_PATH=OPENCV_CONTRIB . where OPENCV_CONTRIB is the location of the opencv_contrib repo on your local machine. | . Verifying OpenCV is CUDA accelerated . The easiest way to quickly verify that everything is working is to check that one of the inbuilt CUDA performance tests passes. For this I have chosen the GEMM test which; runs without any external data; | should be highly optimized on both the GPU and CPU making it &quot;informative&quot; to compare the performance timings later on, and; | has OpenCL versions. | . To run the CUDA performance test simply enter the following into the existing command prompt &quot;%openCvBuild% install x64 vc16 bin opencv_perf_cudaarithm.exe&quot; --gtest_filter=Sz_Type_Flags_GEMM.GEMM/29 . (where %openCvBuild% is your build directory, or the directory which you extracted the downloaded binaries to) the full output is shown below. To verify that everything is working look for the &quot; [ PASSED ] 1 test&quot; text, shown in the image below. Note: If you have set OPENCV_TEST_DATA_PATH then this will fail the sanity check since CUDA 11.0. The above test performed matrix multiplication on a 1024x1024x2 single precision matrix using an RTX 2080 Mobile GPU 100 times, with a mean execution time of 3.36 ms, which can be seen in the following output taken from the image above. [ PERFSTAT ] (samples=100 mean=3.32 median=3.28 min=3.24 stddev=0.1 (3.0%)) . If the test has passed then we can confirm that the above code was successfully run on the GPU using CUDA. For completeness this result is compared with the performance attainable on the CPU and with that obtained using OpenCl (cv::UMat) on both the CPU and GPU using both the C++ and python interfaces in OpenCV MKL/TBB vs cuBLAS. Choosing the compute-capability . The default command line options given above implement NVIDIA&#39;s recommended settings for future hardware compatibility. This means that any programs linked against the resulting opencv_world450.dll shared library should work on all GPU&#39;s currently supported by CUDA 11.1 and all GPU&#39;s released in the future. As mentioned above this comes at a cost, both in terms of compilation time and shared library size. Before discussing the CMake settings which can be used to reduce these costs we need to understand the following concepts: Compute-capability - every GPU has a fixed compute-capability which determines its general specifications and features. In general the more recent the GPU the higher the compute-capability and the more features it will support. This is important because: Each version of CUDA supports different compute-capabilities. Usually a new version of CUDA comes out to suppoort a new GPU architecture, in the case of CUDA 11.0, support was added for the Ampere (compute 8.0, with compute 8.6 added in CUDA 11.1) architecture. On the flip side support for compute 3.0 and 3.2 was dropped. Therefore by choosing to build OpenCv with CUDA 11.1 we have limited ourselves to GPU&#39;s of compute-capability &gt;=3.5. Notice we have not limited ourselves to compute-capability GPU&#39;s &lt;=8.6, the reason for this is discussed in the next section. | You can build opencv_world450.dll to support one or many different compute-capabilities, depending on your specific requirements. | . | Supporting a compute-capability - to support a specific compute-capability you can do either of the following, or a combination of the two: Generate architecture-specific cubin files, which are only forward-compatible with GPU architectures with the same major version number. This can be controlled by passing CUDA_ARCH_BIN to CMake. For example passing -DCUDA_ARCH_BIN=3.0 to CMake, will result in opencv_world450.dll containing binary code which can only run on compute-capability 3.0, 3.5 and 3.7 devices. Futhermore it will not support any specific features of compute-capability 3.5 (e.g. dynamic parallelism) or 3.7 (e.g. 128 K 32 bit registers). In the case of OpenCV 4.4.0 this will not restrict any functionality of the standard CUDA functions on compute capability 3.5 and 3.7 devices, because they only uses features from compute-capability 3.0 and below. This can be confirmed by a quick search of the main and contrib repositories for the __CUDA_ARCH__ flag. | Generate forward-compatible PTX assembly for a virtual architecture, which is forward-compatable with all GPU architectures of greater than or equal compute-capability. This can be controlled by passing CUDA_ARCH_PTX to CMake. For example by passing -DCUDA_ARCH_PTX=8.6 to CMake, the opencv_world450.dll will contain PTX code for compute-capability 8.6 which can be Just In Time (JIT) compiled to architecture-specific binary code by the CUDA driver, on any future GPU architectures. Because of the default CMake rules when CUDA_ARCH_BIN is not explicitly set it will also contain architecture-specific cubin files for GPU architectures 3.5-8.6. | . | PTX considerations - given that PTX code is forward-compatible and cubin binaries are not it would be tempting to only include the former. To understand why this might not be such a great idea, a things to be aware of when generating PTX code: As mentioned previously the CUDA driver JIT compiles PTX code at run time and cache&#39;s the resulting cubin files so that the compile operation should in theory be a one-time delay, at least until the driver is updated. However if the cache is not large enough JIT compilation will happen every time, causing delay every time your program executes.To get an idea of this delay I passed -DCUDA_ARCH_BIN=3.5 and -DCUDA_ARCH_PTX=3.5 to CMake before building OpenCV. I then emptied the cache (default location %appdata% NVIDIA ComputeCache ) and ran the GEMM performance example on a GTX 1060 (compute-capability 6.1), to force JIT compilation. I measured an initial delay of over 3 minutes as the PTX code was JIT compiled before the program started to execute. Following that, the delay of subsequent executions was around a minute, because the default cache size (256 MB) was not large enough to store all the compiled PTX code. Given my compile options the only solution to remove this delay is to increase the size of the cache by setting the CUDA_CACHE_MAXSIZE environmental variable to a number of bytes greater than required. Unfortunately because, &quot;Older binary codes are evicted from the cache to make room for newer binary codes if needed&quot;, this is more of a band aid than a solution. This is because the maximum cache size is 4 GB, therefore your PTX compiled code can be evicted at any point in time if other programs on your machine are also JIT compiling from PTX, bringing back the &quot;one-time&quot; only delay. | For maximum device coverage you should include PTX for the lowest possible GPU architecture you want to support. | For maximum performance NVIDIA recommends including PTX for the highest possible architecture you can. | | . CMake command line options to control cubin/PTX content of the OpenCV shared library . Given (1)-(3) above, the command line options that you want to pass to CMake when building OpenCV will depend on your specific requirements. I have given some examples below for various scenarios given a main GPU of compute-capability 6.1: Firstly stick with the defaults if compile time and shared library size are not an issue. This offers the greatest amount of flexibility from a development standpoint, avoiding the possibility of needing to recompile OpenCV when you switch GPU. | If your programs will always be run on your main GPU, just pass -DCUDA_ARCH_BIN=6.1 to CMake to target your architecture only. It should take around an hour to build, depending on your CPU and the resulting shared library should not be larger than 200 MB. | If you are going to deploy your application, but only to newer GPU&#39;s pass -DCUDA_ARCH_BIN=6.1,7.0,8.0,8.6 and -DCUDA_ARCH_PTX=8.6 to CMake for maximum performance and future compatibility.This is advisable because you may not have any control over the size of the JIT cache on the target machine, therefore including cubin&#39;s for all compute-capabilities you want to support, is the only way be sure to prevent JIT compilation delay on every invocation of your application. | If size is really an issue but you don&#39;t know which GPU&#39;s you want to run your application on then to ensure that your program will run on all current and future supported GPU&#39;s pass -DCUDA_ARCH_BIN=6.1 and -DCUDA_ARCH_PTX=3.0 to CMake for maximum coverage. | . &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; Because the pre-built Windows libraries available for OpenCV do not include the CUDA modules, or support for the Nvidia Video Codec SDK, Nvidia cuDNN, Intel Media SDK or Intel’s Math Kernel Libraries (MKL) or Intel Threaded Building Blocks (TBB) performance libraries, I have included the build instructions, below for anyone who is interested. If you just need the Windows libraries then go to Download OpenCV 4.5.0 with CUDA 11.1. To get an indication of the performance boost from calling the OpenCV CUDA functions with these libraries see the OpenCV 3.4 GPU CUDA Performance Comparisson (nvidia vs intel). . The guide below details instructions on compiling the 64 bit version of OpenCV 4.5.0 shared libraries with Visual Studio 2019, CUDA 11.1, and optionally the Nvidia Video Codec SDK, Nvidia cuDNN, Intel Media SDK, Intel Math Kernel Libraries (MKL), Intel Threaded Building Blocks (TBB) and Python bindings for accessing OpenCV CUDA modules from within Python. . The main topics covered are given below. Although most of the sections can be read in isolation I recommend reading the pre-build checklist first to check whether you will benefit from and/or need to compile OpenCV with CUDA support. . Make sure not to let opencv install for python -DOPENCV_SKIP_PYTHON_LOADER=ON Find example and write about depends - what could be missing. Try installing new env and building. Needs to be in cv2 directory - is this always the case? Some python distributions don&#39;t use the system path therefore without an init, can&#39;t detect dll, Nothing works on miniconda -&gt; which dll is missing? Write usage of process monitor -&gt; Is there an easy way to filter only by files which couldn&#39;t be found -&gt; probably not but could use python Is there an alternative to os.add_dll_directory? No need to add them all -&gt; this would be better handled in the init script? import os os.add_dll_directory(&quot;C: Program Files NVIDIA GPU Computing Toolkit CUDA v11.7 bin&quot;) os.add_dll_directory(&quot;D: 3rd_party deps ffmpeg-n5.0-latest-win64-gpl-shared-5.0 bin&quot;) os.add_dll_directory(&quot;D: build opencv cuda_11_7_cc_8_6_ff_sym install x64 vc17 bin&quot;) ? add init script to do this ? Including pyd . &quot;C: Program Files NVIDIA GPU Computing Toolkit CUDA v11.7 bin&quot;, &quot;D: 3rd_party deps ffmpeg-n5.0-latest-win64-gpl-shared-5.0 bin&quot; . &lt;/div&gt; .",
            "url": "https://cudawarped.github.io/opencv_docs/opencv/cuda/python/nvdec/cudnn/2022/06/08/opencv-windows-cuda-nvdec.html",
            "relUrl": "/opencv/cuda/python/nvdec/cudnn/2022/06/08/opencv-windows-cuda-nvdec.html",
            "date": " • Jun 8, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "Opencv4 Cuda Streams",
            "content": "",
            "url": "https://cudawarped.github.io/opencv_docs/2022/06/07/opencv4-cuda-streams.html",
            "relUrl": "/2022/06/07/opencv4-cuda-streams.html",
            "date": " • Jun 7, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://cudawarped.github.io/opencv_docs/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://cudawarped.github.io/opencv_docs/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://cudawarped.github.io/opencv_docs/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://cudawarped.github.io/opencv_docs/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}